// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import agency "github.com/arangodb/go-driver/agency"
import context "context"
import driver "github.com/arangodb/go-driver"
import mock "github.com/stretchr/testify/mock"
import time "time"

// Agency is an autogenerated mock type for the Agency type
type Agency struct {
	mock.Mock
}

// Connection provides a mock function with given fields:
func (_m *Agency) Connection() driver.Connection {
	ret := _m.Called()

	var r0 driver.Connection
	if rf, ok := ret.Get(0).(func() driver.Connection); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Connection)
		}
	}

	return r0
}

// ReadKey provides a mock function with given fields: ctx, key, value
func (_m *Agency) ReadKey(ctx context.Context, key []string, value interface{}) error {
	ret := _m.Called(ctx, key, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}) error); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RegisterChangeCallback provides a mock function with given fields: ctx, key, cbURL
func (_m *Agency) RegisterChangeCallback(ctx context.Context, key []string, cbURL string) error {
	ret := _m.Called(ctx, key, cbURL)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, string) error); ok {
		r0 = rf(ctx, key, cbURL)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveKey provides a mock function with given fields: ctx, key, condition
func (_m *Agency) RemoveKey(ctx context.Context, key []string, condition ...agency.WriteCondition) error {
	_va := make([]interface{}, len(condition))
	for _i := range condition {
		_va[_i] = condition[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, ...agency.WriteCondition) error); ok {
		r0 = rf(ctx, key, condition...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveKeyIfEqualTo provides a mock function with given fields: ctx, key, oldValue
func (_m *Agency) RemoveKeyIfEqualTo(ctx context.Context, key []string, oldValue interface{}) error {
	ret := _m.Called(ctx, key, oldValue)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}) error); ok {
		r0 = rf(ctx, key, oldValue)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnregisterChangeCallback provides a mock function with given fields: ctx, key, cbURL
func (_m *Agency) UnregisterChangeCallback(ctx context.Context, key []string, cbURL string) error {
	ret := _m.Called(ctx, key, cbURL)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, string) error); ok {
		r0 = rf(ctx, key, cbURL)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteKey provides a mock function with given fields: ctx, key, value, ttl, condition
func (_m *Agency) WriteKey(ctx context.Context, key []string, value interface{}, ttl time.Duration, condition ...agency.WriteCondition) error {
	_va := make([]interface{}, len(condition))
	for _i := range condition {
		_va[_i] = condition[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, value, ttl)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}, time.Duration, ...agency.WriteCondition) error); ok {
		r0 = rf(ctx, key, value, ttl, condition...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteKeyIfEmpty provides a mock function with given fields: ctx, key, value, ttl
func (_m *Agency) WriteKeyIfEmpty(ctx context.Context, key []string, value interface{}, ttl time.Duration) error {
	ret := _m.Called(ctx, key, value, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}, time.Duration) error); ok {
		r0 = rf(ctx, key, value, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteKeyIfEqualTo provides a mock function with given fields: ctx, key, newValue, oldValue, ttl
func (_m *Agency) WriteKeyIfEqualTo(ctx context.Context, key []string, newValue interface{}, oldValue interface{}, ttl time.Duration) error {
	ret := _m.Called(ctx, key, newValue, oldValue, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}, interface{}, time.Duration) error); ok {
		r0 = rf(ctx, key, newValue, oldValue, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
